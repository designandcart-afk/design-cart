import { supabase } from './supabase';
import type { Database } from './database.types';
import type { UploadedFile } from './uploadAdapter';

type Tables = Database['public']['Tables'];
type Profile = Tables['profiles']['Row'];
type Project = Tables['projects']['Row'];
type Product = Tables['products']['Row'];
type Message = Tables['messages']['Row'];
type Order = Tables['orders']['Row'];
type File = Tables['files']['Row'];

export const api = {
  // Profile
  async getProfile(userId: string): Promise<Profile | null> {
    const { data, error } = await supabase
      .from('profiles')
      .select()
      .eq('id', userId)
      .single();
    
    if (error) throw error;
    return data;
  },

  // Projects
  async getProjects(userId: string): Promise<Project[]> {
    const { data, error } = await supabase
      .from('projects')
      .select(`
        *,
        client:client_id(id, full_name),
        designer:designer_id(id, full_name)
      `)
      .or(`client_id.eq.${userId},designer_id.eq.${userId}`)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  },

  async createProject(project: Tables['projects']['Insert']): Promise<Project> {
    const { data, error } = await supabase
      .from('projects')
      .insert(project)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },

  // Products
  async getProducts(filters?: {
    category?: string;
    minPrice?: number;
    maxPrice?: number;
    colors?: string[];
    search?: string;
  }): Promise<Product[]> {
    let query = supabase
      .from('products')
      .select()
      .eq('status', 'active');

    if (filters?.category) {
      query = query.eq('category', filters.category);
    }
    
    if (filters?.minPrice) {
      query = query.gte('price', filters.minPrice);
    }
    
    if (filters?.maxPrice) {
      query = query.lte('price', filters.maxPrice);
    }
    
    if (filters?.colors?.length) {
      query = query.in('color', filters.colors);
    }
    
    if (filters?.search) {
      query = query.ilike('title', `%${filters.search}%`);
    }

    const { data, error } = await query.order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  },

  // Messages
  async getMessages(projectId: string): Promise<Message[]> {
    const { data, error } = await supabase
      .from('messages')
      .select(`
        *,
        sender:sender_id(id, full_name)
      `)
      .eq('project_id', projectId)
      .order('created_at', { ascending: true });
    
    if (error) throw error;
    return data;
  },

  async sendMessage(message: Tables['messages']['Insert']): Promise<Message> {
    const { data, error } = await supabase
      .from('messages')
      .insert(message)
      .select(`
        *,
        sender:sender_id(id, full_name)
      `)
      .single();
    
    if (error) throw error;
    return data;
  },

  // Files
  async uploadFile(file: File, projectId: string, uploaderId: string): Promise<UploadedFile> {
    // Upload to Supabase Storage
    const fileExt = file.name.split('.').pop();
    const filePath = `${projectId}/${Math.random()}.${fileExt}`;
    
    const { error: uploadError } = await supabase.storage
      .from('files')
      .upload(filePath, file);
    
    if (uploadError) throw uploadError;

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
      .from('files')
      .getPublicUrl(filePath);

    // Create file record
    const { data, error } = await supabase
      .from('files')
      .insert({
        name: file.name,
        size: file.size,
        mime_type: file.type,
        url: publicUrl,
        project_id: projectId,
        uploader_id: uploaderId,
        type: file.type.startsWith('image/') ? 'image' : 'file',
      })
      .select()
      .single();
    
    if (error) throw error;

    return {
      id: data.id,
      name: data.name,
      size: data.size,
      mime: data.mime_type,
      url: data.url,
      type: data.type,
      thumbnailUrl: data.thumbnail_url,
    };
  },

  // Orders
  async createOrder(order: Tables['orders']['Insert'], items: Tables['order_items']['Insert'][]): Promise<Order> {
    const { data, error } = await supabase
      .rpc('create_order', {
        order_data: order,
        items_data: items,
      });
    
    if (error) throw error;
    return data;
  },

  async getOrders(userId: string): Promise<Order[]> {
    const { data, error } = await supabase
      .from('orders')
      .select(`
        *,
        items:order_items(
          *,
          product:product_id(*)
        ),
        project:project_id(*)
      `)
      .eq('client_id', userId)
      .order('created_at', { ascending: false });
    
    if (error) throw error;
    return data;
  },
};